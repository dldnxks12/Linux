### Process & Thread 

- Process

     프로세스는 실행 중인 프로그램을 말한다.

    → 생성, 준비, 대기, 실행완료 등의 다양한 상태를 가지고 있다. 
	- CPU는 한 순간에 하나의 프로세스만 처리할 수 있기 때문에 다른 프로세스들은 대기해야 한다.
		- CPU를 사용하기 위해 CPU 시간을 분할해서 프로세스에 할당한다.
		- 시분할 시스템에서는 CPU에서 프로세스들이 돌아가면서 실행 
			- CPU의 Core는 매순간 하나의 프로세스만 실행 -> 주기를 아주 짧게 나누면 여러 프로그램이 동시에 수행되는 것 처럼 보인다.
			- 이렇게 나누어진 짧은 시간을 Quantum time 이라 한다.
			- Quantum time 단위로 나누어진 여러 프로세스들이 돌아가면서 실행되는데, 이 프로세스들은 프로세스 Queue에 의해 관리된다.
	- 프로세스들은 각각의 상태를 가지는데, 이 상태를 관리하는 PCB(Process Contro Block)에 이 상태를 저장한다.

    → Linux에서는 시분할 알고리즘을 통해 프로세스를 제어하는데, 이를 통해 여러 개의 일을 동시에 할 수 있다. ⇒ Thread 

- Process Data Structure

	사용자 구조 -> 프로세스 테이블 -> 프로세스 영역 테이블(가상 메모리) -> 메모리(실제 메모리)

	사용자 구조는 프로세스 수행 중에 필요한 정보를 저장한다. user structure는 <user.h> header에 정의 되어 있다.
	프로세스 테이블은 프로세스 관리에 필요한 정보들을 저장한다.

	- 리눅스에서 프로세스에 대한 정보는 task_struct 구조체를 통해 관리된다.
		- 위 구조체는 프로세스에 관한 모든 정보를 보관한다.
		- 아주 많은 구조체 멤버로 이루어져 있다.
			- task_struct 구조체에 대한 정보는 ps 명령어를 통해 불러올 수 있다.
			- 현재 실행되는 프로세스들의 정보는 /proc 디렉터리를 통해 확인할 수 있다.
				- ls /proc/

- Process command in CLI

	ps : process check

		pid : process id
		ppid : parent process id
		STAT : state of process 
			- P : 실행 가능 or 실행 중
			- D : 인터럽트 할 수 없는 대기 상태 
			- S : 20초 미만의 Sleep 상태
			- I : 20초 이상 길게 잠든 상태
			- R : CPU를 점유하기 위해 대기하고 있는 상태
			- Z : Zombie 상태 (프로세서가 종료될 때, 다른 문제로 인해 완전히 완료되지 못한 상태를 의미)
			- T : 일시정지 상태

	kill : process kill

	top : 현재 시스템의 프로세스 우선순위, CPU 등의 시스템 사용량 정보 	

- Signal

    시그널은 프로세스들 사이에서 비동기적인 사건의 발생을 전달하는 방법

    → Ctrl+C (종료)

    → 숫자를 0으로 나누는 등의 error를 알리기 위한 signal

    → Linux에서 이러한 signal을 처리하는 방법도 지원한다.
	- 실행 중인 프로세스는 사용자가 terminal에서 ctrl+c or ctrl+z를 눌러 발생하는 interrupt에 의해 멈추거나 중지된다.
	- 이 때 OS에서 Signal이 발생해 해당 process에 전달된다.

- fork() , exec()

    멀티 프로세스 환경에서 (동시에 여러 개의 프로그램을 돌리는 것) 새 프로세스를 생성

    → fork() 함수 사용

    → 일반적으로 client의 요청에 따라 동일한 서비스를 제공하는 네트워크 서비스(naver)의 경우, 하나의 프로세스를 복제해서 부모와 자식이 동시에 각각 관련된 기능을 실행할 수 있다.

    → fork() 함수로 자식 프로세스를 생성한 다음 exec() 함수로 새로운 프로그램을 실행

    → POSIX에서는 fork와 exec을 함께 실행하는 posix_spawn() 함수를 제공

- IPC (Inter Process Protocol) - Pipe, FIFO, 공유 메모리

    프로세스들 간에 공유하는 공간이 없기 때문에 이들 끼리 소통하는 방법이 필요하다.

    이를 위한 IPC로 파이프, FIFO, 공유 메모리 등의 방법이 사용된다.

    → Pipe : 부모 자식 프로세스 간에만 서로 소통이 가능

    → FIFO : 모든 프로세스들 간에 소통이 가능

- Thread

    스레드는 일의 처리 단위로 프로세스에 비해 빠르게 생성할 수 있다.

    또한 서로 공유되는 메모리를 이용해서 서로 간의 데이터를 전달할 수 있다.

    → 즉, 프로세스에 비해 빠르게 생성되고, 메모리를 공유한다.

    → 하지만 모든 스레드가 같은 메모리를 공유하기 때문에 동기화 문제가 발생할 수 있다.

    → 세마포어 or 뮤텍스를 이용해서 해결
