### 멀티 프로세스와 다중 처리 프로그밍


#### 프로세스 처리

각각의 프로세스는 PID(process Id)를 부여받는다.

Linux를 부팅하면 생성되는 swapper는 커널에서 직접 생성하지만, 다른 프로세스들은 기존의 프로세스를 복사해서 사용한다.

init process는 swapper를 복사해서 생성된다.

일반적으로 PID 0은 스케쥴러이고, PID 1은 init 프로세서, PID 2번부터 페이지 데몬 등의 프로그램이 실행된다.

이와 같이 프로세스가 생성될 때 부모 프로세스를 복사해서 사용된다. 

예시) terminal에서 ps aux | more 라는 command를 입력

	이는 init process에서 생성된 bash (shell) process에서 프로그램을 실행시킨다.
	
	bash는 fork()라는 시스템 함수를 호출해 자기 자신을 복사해서 pid는 다르지만 내용은 같은 프로세스를 만든다.

	그리고 다른 프로그램을 수행하기 위해 exec()라는 시스템 호출을 사용해서 새로 생성한 프로세스 공간에 새로운 내용으로 채우고 코드를 실행하게 된다. 

	즉, ps 명령어와 more 명령어를 위한 2개의 프로세스를 생성하고, 파이프(|)를 이용해서 두 프로세스 간 IPC를 통해 내용을 전달하게 된다.


- swapper를 제외한 프로세스들은 모두 부모 process에서 파생되어 나오기 때문에 ppid를 가진다.

	Linux에서는 현재 실행 중인 프로세스의 pid와 부모 프로세스인 ppid 를 알 수 있도록 관련 System call이 존재한다.
	
	= getpid(), getppid()

	
#### 프로세스 종료 - exit()

C의 main() 함수는 int 형 반환값을 갖는다.

App이 종료되면 실행 결과를 OS(Linux)에 반환하고 , OS는 그 프로세스가 열었던(open()) fd를 모두 닫는다.(close())

이후 프로세스가 차지하고 있던 메모리를 가용 메모리 풀(pool)로 반환한다.


App을 종료할 떄, main()함수에서 return 문을 이용할 수 있는데 실질적으로는 exit() 함수가 호출된다.

C 컴파일러는 main()에서 값을 return하는 경우 자동적으로 exit()함수가 호출되도록 코드를 생성한다.

exit()함수는 표준 입출력 정리 루틴을 수행하고 _exit() 함수를 호출한다. 

	- exit() 과 _exit()의 차이는 표준 입출력과 관련된 정리 작업을 수행하는것과 하지 않는 것이다. 

		- 표준 입출력 정리 ? file descriptor 제거, stream 끊기, 버퍼 비우기 등 ..

			- exit() : file의 경우 file stream을 끊고, fd 제거 후 fclose()함수를 호출해서 fflush() 수행

	#include <stdlib.h> // header for exit() function
	
	void exit(int status)  // C에서 0은 False , 1은 True지만 exit()에서는 1이 False, 0이 True!

		
#### 프로세스 생성 - fork()

일반적으로 프로그램을 수행하기 위해서는 fork(), exec() 함수를 함께 사용한다. 

fork() 함수는 프로세스를 생성한다.

	1. 호출한 프로세스와 동일한 프로세스를 새로 생성 (내용 동일 즉, 프로세스 복제 수행)

	2. 새로운 프로세스 ID 할당 

	3. 새로 생성한 프로세스는 호출한 프로세스를 부모 프로세스로 한다.

	fork() 함수의 호출이 완료되면 자식과 부모 모두 동일한 프로그램 코드를 가지고 있는데, 

	두 프로세스 모두 fork()함수를 호출한 다음 line의 코드부터 동시에 실행된다. 

	이 함수는 fork() 함수 사용 전 open() 함수를 통해 file을 열었다면 fd도 공유한다. 


exec() 함수는 

	1. 프로세스의 공간에 새로운 프로그램의 바이너리 코드를 올린다.

	2. 프로세스의 내용은 변경하지만 프로세스 ID는 변경되지 않는다.



	자식 프로세스가 생성되면 커널이 프로세스 테이블에 등록하고 메모리를 할당해준다.

	일반적으로 프로세스가 생성되면, 부모와 자식 프로세스는 text 영역은 공유, stack, heap, data 영역은 복사해간다.


다른 프로그램을 수행하는 경우 fork() 함수를 수행한 후 내용을 바꿔야하는데 이를 위해 바로 exec()함수를 수행한다.

이렇게하면 fork() 함수가 부모 프로세스의 text영역을 복사하기 전에 다른 프로그램의 바이너리로 채우게 된다. 


Linux에서는 이를 위해 vfork() 하는 함수를 제공한다. vfork()함수는 바로 exec()함수를 수행할 것을 염두에 두고,

자식 프로세스를 생성할 때 부모 프로세스의 메모리 영역을 복사하지 않는다. 

	- 즉, exec() or exit() 호출 전까지 메모리 영역을 공유한다. 
		
		- 부모 프로세스는 멈춰도 자식 프로세스가 항상 먼저 실행되는 것을 보장한다. 

	- vfrok() 함수는 부모 프로세스에서 vfork()호출 후 exec() 전에 메모리가 변경되면 문제가 발생한다.

	- 또한 최근에는 보안 문제상 vfork()를 사용하지 않기를 강력히 권장한다. 
	
		
#### Linux 부팅 시 프로세스

Linux가 부팅된 후 가장 처음 생서되는 프로세서(pid 0)는 swapper이다. (스케쥴링에 사용되는 프로세서들을 관리하는 프로세서)

swapper는 프로세스들을 메모리와 디스크 사이에서 swap해주는 역할을 한다. (즉, 사용할 때 메모리에 올리고, 안할 때 디스크로 내리고)

또한 swapper는 init 프로세서 (pid 1)를 생성한다. 이후 pid 0 프로세서는 감춰지고, pid 1 프로세서만 남아서 다른 모든 프로세스의 부모 프로세스가 된다.


- init process : pid = 1 , ppid = 0


