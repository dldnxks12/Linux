### 프로세스 사이의 통신 IPC (Inter Process Communication)

일반적으로 프로세스 간에는 공유되는 부분이 없기 때문에 서로 통신을 하기 위해 방법이 필요!


1. Simple IPC 

		- 버퍼로 사용할 file을 하나 만들어 놓고 이 file을 경유해서 데이터를 쓰고 읽는 방법

		- file 입출력(fread, fwrite)을 통해 통신 가능 

			1. 파이프 (단뱡향)

			2. FIFO (단뱡향)

			3. Socket (양방향) 

	** 문제 

		- OS에 따라 다르지만 일반적으로 하나의 프로세스가 하나의 file을 열 수 있기 때문에 여러 프로세스가 접근할 때 충돌이 발생할 수 있다. 

		- 즉, 입출력 다중화 시 문제 해결이 어렵다. 또한 시스템 콜이 빈번해서 OS kernal에 부하가 심하다.

	- 따라서 위와 같은 문제를 보완한 통신 방법으로 Posix IPC가 개발되었다.

2. UNIX V / XSI IPC (X System Interface)

		- UNIX V / XSI IPC 통신 방법은 기존 PIPE, FIFO, Socket과 달리 file을 경유하지 않는다.
			
			1. 메세지 큐
		
			2. 세마포어

			3. 공유 메모리 

		위 3가지 방법은 UNIX 시스템 V에서 처음 제안된 IPC로 각 IPC 기법은 독특한 특징이 있다.

		각 방법마다 고유의 시스템 Call을 사용하기 때문에 기존 파일 시스템에서 제공하는 System Call을 사용할 수 없다. 

		- UNIX SYSTEM V에서 설정된 IPC 채널 정보를 확인하고 싶을 떄는 다음 명령어를 사용하자

			$ ipcs [-q | -m | -s] 

				또한 채널 생성과 삭제는 다음 명령어를 사용한다.

				& ipcmk , & ipcrm
		

- Header File 

	메세지 큐 : <sys/msg.h>

	세마포어  : <sys/sem.h>

	공유 메모리 : <sys/shm.h>

- IPC 채널 생성/열기

	메세지 큐 : msgget()

	세마포어 : semget()

	공유 메모리 : shmget()

- IPC 채널 제어/삭제 

	메세지 큐 : msgctl()

	세마포어 : semctl()

	공유 메모리 : shmctl()

- IPC 동작

	메세지 큐 : msgsnd(), msgrcv()

	세마포어 : semop()

	공유 메모리 : shmat(), shmdt()


- 네임스페이스 : 생성 가능한 채널 이름의 집합  (채널 : 우리 통신할 건데 채널을 열어야 통신을 하지 !)

- UNIX System V의 IPC에서는 모든 키에 동일한 key_t 타입을 사용한다. (key? 통신하려면 누가 누군지 서로 알아봐야지!)

- 키는 ftok() 함수로 생성 가능하며, 프로세스가 채널 이름 할당을 요청할 때, 커널은 동일한 채널 이름을 중복 할당하면 안된다. 

	키를 생성한 후 msgget(), semget(), shmget() 함수와 같이 Unix 시스템 V의 IPC 채널을 가져올 수 있다.

		key와 여기에 해당하는 채널 할당 (이 Key와 채널로 통신할 것 !)

	세 함수 모두 첫 인자로 키 값을 사용하고 마지막 인자로 flag 값을 사용한다. (p291 참고)

	
	IPC 채널을 가져오면 msgctl(), semctl(), shmctl() 함수를 통해 IPC 동작을 수행할 수 있다. 



3. POSIX IPC 
		
		UNIX V/XSI IPC 통신의 취약점을 보완하기 위해 발전된 통신 방법 
	
		- POSIX IPC 통신 방법은 file을 경유하지 않는다.

			1. 메세지 큐

			2. 네임드 세마포어

			3. 공유 메모리 (mmap)

		
#### IPC 간단 특징

파이프 : 부모 프로세스와 자식 프로세스 사이에서만 Only 통신 가능 

FIFO, 소켓, 메세지 큐, 공유 메모리 : 서로 관계없는 프로세스 사이에서도 통신 가능		                                                                                                                                                                                                                                                                                                                                        

#### IPC (Inter Process Communication)

![111](https://user-images.githubusercontent.com/59076451/127955308-db00bcdb-1a70-40e8-a2a8-e48c7473e5fc.jpg) 

## Simple IPC

### 파이프

파이프는 UNIX 프로세스 간의 "단방향" 통신 방법으로 $ ps aux | more 와 같이 셸에서 많이 사용된다. 

통신을 위한 file buffer는 커널 내에 존재한다. 보통 4KB 이상의 크기를 가지고 있음

단방향 통신 방법이기 때문에 만일 양방향 통신을 원한다면 두 개의 파이프를 써야한다. 

	pipe() 함수를 이용해서 파이프를 생성할 수 있다.

	인자로는 2개의 fd에 대한 array를 넣어준다. 

	** PIPE 매커니즘 

		파이프는 부모와 자식 프로세스 간의 통신을 위해 사용한다.

		자식 프로세스의 파일 fd 상속으로 IPC 채널의 조인 문제를 해결한다.

		파이프를 사용하기 위해 부모 프로세스에서 파이프를 생성하고, fork() 수행 시 자식 프로세스에도 같은 파이프가 상속된다. 

			- fork 이전에 file을 open시 발생하는 fd가 똑같이 상속되어 자식 프로세스에서도 같은 fd를 가진다. 

		부모와 자식 프로세스에서는 파이프의 방향을 결정한 후 필요없는 fd를 닫고 나머지 fd로 통신을 시작한다. 

		
		파이프 read()

		파이프에 존재하는 데이터가 read() 함수에서 읽고 싶은 데이터의 양보다 적어도 read() 함수는 데이터를 읽고 반환해준다.

		파이프 끝에 데이터를 쓰는 프로세스가 없으면 read() 함수는 0을 반환한다.

		파이프 write()

		write() 함수에서 쓰고 싶은 데이터의 양이 파이프의 버퍼보다 크면, write() 은 원자적으로 동작하지 않는다.

		파이프의 끝에서 읽을 수 있는 프로세스가 없으면 write() 호출 시 SIGPIPE 시그널 생생

			- 원자적(atomic)? 

				- 어떤 작업이 실행될 때 언제나 완전히 종료되거나, 그럴 수 없을 때는 아예 실행하지 않는 것 


#### FIFO

FIFO는 파이프와 유사한 단방향 통신을 위한 방법

하지만 부모와 프로세스 사이에서만 소통이 가능한 파이프와 달리 다른 프로세스 사이에서도 소통이 가능하다.

파이프와 기능은 비슷하지만 IPC 조인에 사용하는 이름이 있다고 해서 네임드 파이프 라고도 불린다.		

	FIFO를 사용하기 위해서는 채널 역할을 하는 FIFO 파일을 생성

	이 파일은 데이터 전송에 사용하는 것이 아님! -> 단순히 프로세스 간 채널을 확립하기 위해서만 사용

	서버 프로세스나 클리어언트 프로세스는 각자 동일한 FIFO 파일을 열고, 이 때 얻은 파일 디스크립터를 이용해서 통신할 수 있다!


	FIFO 사용 

		mkfifo() 함수를 이용해서 FIFO 파일을 생성한다.

		이어서 open() 함수를 호출하고 반환되는 fd를 이용해서 read()나 write()로 통신을 수행한다.
 
			FIFO를 사용하기 위해선 서버와 클라이언트 총 2개의 코드를 짜야한다.

## UNIX V / XSI IPC

#### Message Queue

	유닉스 시스템 V의 프로세스 간의 통신을 하기 위해 사용되는 메커니즘 중 하나 (쌍방향 통신)

	메일 시스템과 비슷한데, 입출력 data를 커널 내부에 메세지 리스트 형태로 저장해둔다!

		또한 커널 내부에 저장해두기 때문에 프로세스가 종료되어도 메세지가 사라지지 않는다.

			- 내부적으로 Queue의 자료구조를 갖기 때문에 메세지를 읽어 들인 후 삭제한다. 

	FIFO와 비슷하지만, 메세지가 중간에 저장되기 때문에 서버와 클라이언트들이 동일 시점에 데이터를 주고 받을 필요가 없다.


	메세지 큐는 msqid_ds 구조체를 사용하고, 키와 채널을 생성하기 위해 ipc 관련 header를 가져와야한다.

	->  <sys/msg.h> , <sys/ipc.h>
